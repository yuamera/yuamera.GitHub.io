<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang GC</title>
      <link href="/post/b8c35bd7580c/"/>
      <url>/post/b8c35bd7580c/</url>
      
        <content type="html"><![CDATA[<p>Go语言的垃圾回收（GC）机制是一个不断演变和改进的领域，以下是Go GC演变史的一些主要里程碑：</p><ul><li><p>Go 1.0（2012年3月）：Go语言的初始版本中使用的是基于标记-清除（Mark-and-Sweep）算法的垃圾回收器。该算法标记出所有仍在使用的对象，并清除所有不再使用的对象，但是在执行垃圾回收时会导致程序暂停。</p></li><li><p>Go 1.3（2014年6月）：Go语言的垃圾回收器从标记-清除算法转变为基于标记-整理（Mark-and-Compact）算法。该算法除了标记出所有仍在使用的对象，还会将其移动到堆的一个端部，从而减少堆内碎片的数量。但是在执行垃圾回收时仍会导致程序暂停。</p></li><li><p>Go 1.5（2015年8月）：Go语言的垃圾回收器实现了并发标记和清理（Concurrent Mark and Sweep），这意味着GC可以在程序继续运行的情况下进行。它还实现了可达性分析算法，该算法不仅标记活动对象，而且还标记它们之间的关系，从而更好地理解程序状态。</p></li><li><p>Go 1.6（2016年2月）：Go语言的垃圾回收器实现了增量标记和清理（Incremental Mark and Sweep），这意味着GC可以分解为多个阶段，并在每个阶段之间交替运行程序代码和GC代码。这有助于减少GC引起的暂停时间，但也增加了GC的开销。</p></li><li><p>Go 1.8（2017年2月）：Go语言的垃圾回收器引入了屏障技术，这使得GC更好地掌握程序状态。屏障技术可以跟踪程序对对象的写操作，并在写入后立即更新相应的指针，从而使垃圾回收器可以更好地识别对象的状态。</p></li><li><p>Go 1.14（2020年2月）：Go语言的垃圾回收器引入了并发标记周期的增量化，从而减少了每个GC周期的暂停时间。此外，它还提供了一个新的标志，可以在GC时打印详细的GC统计信息。</p></li></ul><p>总之，随着时间的推移，Go语言的垃圾回收器不断发展和改进，以提高程序性能和降低GC开销。新版本的垃圾回收器通常会引入新的算法和技术，以减少程序暂停</p><p>Golang 最新的 GC 是怎么实现的？</p><p>在我的知识截止日期2021年9月，Go语言最新的垃圾回收（GC）实现是Go 1.17版本中的Go GC 1.5。该版本的垃圾回收器具有以下一些特点：<br>紧凑的堆：与早期版本的垃圾回收器相比，新的GC实现可以更好地压缩和管理内存。在垃圾回收时，它可以将不再使用的内存释放并重新组织，从而减少内存碎片。<br>并发标记：GC 1.5具有更快的并发标记算法，可以在不暂停程序的情况下标记对象，以识别哪些对象可以回收。此外，它还可以更快地恢复堆内存中的对象。<br>延迟清理：新的GC实现允许清理线程在标记阶段结束后更晚地清理垃圾，这有助于减少程序的暂停时间。<br>总之，新的垃圾回收实现可以更好地管理和压缩内存，并减少程序暂停时间。不过，Go语言的垃圾回收机制是一个不断改进的领域，因此可能会在未来的版本中有新的更新和改进。</p><p>References</p><p><a href="https://go.dev/blog/ismmkeynote">https://go.dev/blog/ismmkeynote</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
