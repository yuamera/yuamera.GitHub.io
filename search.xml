<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go 垃圾回收器指南</title>
      <link href="/post/a9a9671922dd/"/>
      <url>/post/a9a9671922dd/</url>
      
        <content type="html"><![CDATA[<p>Go官方原文: <a href="https://tip.golang.org/doc/gc-guide">A Guide to the Go Garbage Collector</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本指南旨在帮助高级 Go 用户通过深入了解 Go 垃圾回收器来更好地理解其应用程序成本，并提供指导，以利用这些见解改进其应用程序的资源利用率。它不假设任何垃圾回收知识，但假定熟悉 Go 编程语言。</p><p>Go 语言负责安排 Go 值的存储，在大多数情况下，Go 开发人员不需要关心这些值存储在哪里，或者为什么（如果有的话）。实际上，这些值通常需要存储在计算机物理内存中，而物理内存是有限的资源。由于它是有限的，因此必须仔细管理内存并回收内存，以避免在执行 Go 程序时用尽内存。 Go 实现的工作是根据需要分配和回收内存。</p><p>自动回收内存的另一个术语是垃圾收集。在高层次上，垃圾收集器（或简称 GC）是一个系统，它通过识别不再需要的内存部分，代表应用程序回收内存。 Go 标准工具链提供了一个运行时库，该运行时库随每个应用程序一起提供，并包括垃圾回收器。</p><p>请注意，本指南所描述的垃圾收集器的存在并不是 Go 规范所保证的，只是该语言本身管理 Go 值的底层存储。这种省略是故意的，并允许使用根本不同的内存管理技术。</p><p>因此，本指南是关于 Go 编程语言的特定实现，并可能不适用于其他实现。具体来说，以下指南适用于标准工具链（gc Go 编译器和工具）。 Gccgo 和 Gollvm 都使用非常相似的 GC 实现，因此许多相同的概念也适用，但详细信息可能会有所不同。</p><p>此外，这是一个不断发展的文档，随着时间的推移会进行更改，以最好地反映 Go 的最新发布。本文档当前描述的垃圾收集器是 Go 1.19 的垃圾收集器。</p><h2 id="Go-值存储的位置"><a href="#Go-值存储的位置" class="headerlink" title="Go 值存储的位置"></a>Go 值存储的位置</h2><p>在我们深入了解 GC 之前，让我们先讨论一下不需要由 GC 管理的内存。</p><p>例如，存储在局部变量中的非指针 Go 值可能根本不会由 Go GC 管理，而是 Go 将会安排与其创建时的词法作用域相关联的内存分配。通常，这比依赖 GC 更有效，因为 Go 编译器能够预测何时可以释放该内存并发出清理机器指令。通常，我们将这种方式分配 Go 值的内存称为“栈分配”，因为该空间存储在 goroutine 栈上。</p><p>由于 Go 编译器无法确定其生命周期，无法以这种方式分配内存的 Go 值被认为逃逸到堆上。堆可以被认为是用于内存分配的杂项区域，当需要将 Go 值放置在某处时，就会使用它。在堆上分配内存的行为通常称为“动态内存分配”，因为编译器和运行时可以做出非常少的假设，无法确定何时可以清除此内存。这就是 GC 的作用：它是一个专门识别和清理动态内存分配的系统。</p><p>Go 值可能需要逃逸到堆的原因有很多。其中一个原因可能是它的大小是动态确定的。例如，由变量而不是常量决定切片的初始大小的后备数组。请注意，逃逸到堆必须是可传递的：如果将对 Go 值的引用写入已确定逃逸的另一个 Go 值中，那么该值也必须逃逸。</p><p>Go 值是否逃逸取决于其使用的上下文和 Go 编译器的逃逸分析算法。尝试精确列举值何时逃逸将是脆弱且困难的：算法本身是相当复杂的，并且在 Go 发布之间会发生更改。有关如何确定哪些值会逃逸以及哪些值不会逃逸的更多详细信息，请参见有关消除堆分配的部分。</p><h2 id="追踪式垃圾回收"><a href="#追踪式垃圾回收" class="headerlink" title="追踪式垃圾回收"></a>追踪式垃圾回收</h2><p>垃圾回收可能指自动回收内存的许多不同方法，例如引用计数。在本文档的上下文中，垃圾回收指的是追踪式垃圾回收，该回收方法通过追踪指针的传递性来识别正在使用的对象，即所谓的活动对象。</p><p>让我们更严格地定义这些术语。</p><ul><li><p>对象 - 对象是包含一个或多个Go值的动态分配内存。</p></li><li><p>指针 - 引用对象内任何值的内存地址。这自然包括Go值的形式*T，但也包括内置Go值的部分。字符串，切片，通道，映射和接口值都包含GC必须跟踪的内存地址。</p></li></ul><p>对象和指向其他对象的指针共同形成对象图。为了识别活动内存，GC从程序的根开始遍历对象图，这些根是确切正在使用的对象的指针。局部变量和全局变量是两个根的示例。遍历对象图的过程称为扫描。</p><p>这个基本算法适用于所有追踪式GC。追踪式GC的不同之处在于它们发现内存活动后所做的事情。Go的GC使用标记-清除技术，这意味着为了跟踪其进度，GC也会将其遇到的值标记为活动的。一旦追踪完成，GC就会遍历堆中的所有内存，并将所有未标记的内存可供分配。这个过程称为清扫。</p><p>您可能熟悉的一种替代技术是将对象实际移动到内存的新部分，并留下一个转发指针，稍后用于更新所有应用程序的指针。我们将以这种方式移动对象的GC称为移动GC；Go具有非移动GC。</p><h1 id="GC-周期"><a href="#GC-周期" class="headerlink" title="GC 周期"></a>GC 周期</h1><p>由于Go GC是一个标记-清扫GC，因此它通常分为两个阶段：标记阶段和清扫阶段。虽然这个说法可能听起来有点自相矛盾，但它包含了一个重要的见解：在所有内存都被追踪之前，不可能将内存释放回分配池，因为可能仍有未扫描的指针使对象保持存活状态。因此，清扫的行为必须完全与标记的行为分离。此外，当没有与GC相关的工作需要执行时，GC可能根本不会活跃。GC会不断地在清扫、关闭和标记这三个阶段之间进行循环，这就是所谓的GC周期。为了本文档的目的，我们假设GC周期从清扫开始，然后关闭，最后是标记。</p><p>接下来的几节将专注于建立GC成本的直觉，以帮助用户调整GC参数以获得最大的效益。</p><h2 id="理解成本"><a href="#理解成本" class="headerlink" title="理解成本"></a>理解成本</h2><p>垃圾回收器本质上是建立在更为复杂的系统之上的复杂软件。当尝试理解垃圾回收器并调整其行为时，很容易陷入细节之中。本节旨在提供一个框架，用于推理Go GC成本并调整参数。</p><p>首先，考虑基于三个简单公理的GC成本模型。</p><p>GC仅涉及两种资源：CPU时间和物理内存。</p><p>GC的内存成本包括存活的堆内存、在标记阶段之前分配的新堆内存以及元数据空间。即使与前面的成本成比例，元数据空间相对较小。</p><p>注：存活的堆内存是由前一个GC周期确定为存活的内存，新堆内存是在当前周期分配的任何内存，可能在结束时是存活的也可能是死的。</p><p>GC的CPU成本被建模为每个周期的固定成本和与存活堆的大小成比例的边际成本。</p><p>注：从渐近意义上讲，扫描比标记和扫描更糟糕，因为它必须执行与整个堆的大小成比例的工作，包括被确定为不活动（即“死亡”）的内存。然而，在当前的实现中，扫描比标记和扫描要快得多，所以可以在本讨论中忽略其相关成本。</p><p>这个模型简单而有效：它准确地将GC的主要成本分类。但是，该模型未说明这些成本的大小以及它们如何相互作用。为了建立这种模型，请考虑以下情况，从这里开始称为稳态。</p><p>应用程序分配新内存的速率（每秒字节数）是恒定的。</p><p>注：重要的是要理解，此分配速率完全独立于新内存是否为活动内存。它们中的任何一个都可能是活动的，全部可能是活动的，也可能是其中的一些是活动的。（除此之外，一些旧堆内存也可能死亡，因此，如果该内存为活动内存，则活动堆大小并不一定增加。）</p><p>为了更具体地说明，考虑一个Web服务，为其处理的每个请求分配2 MiB的总堆内存。在请求期间，最多有512 KiB的2 MiB保持活动状态，而当服务完成处理请求时，所有这些内存都会死亡。现在，为了简单起见，假设每个请求大约需要1秒钟才能处理完全。然后，持续的请求流，例如每秒100个请求，将导致200 MiB&#x2F;s的分配速率和50 MiB的峰值活动堆。</p><p>应用程序的对象图每次看起来都差不多（对象大小相似，指针数量大约相同，图的最大深度大约相同）。</p><p>另一种思考方式是，GC的边际成本是恒定的。</p><p>注：稳态可能看起来有点牵强，但它代表了某个恒定工作量下应用程序的行为。当然，尽管应用程序在执行过程中负载可以改变，但通常应用程序的行为看起来像是一串这些稳态，之间还有一些短暂的行为。</p><p>注：稳态不对活跃堆（live heap）做任何假设。它可能会随着每个后续的GC周期而增长，也可能缩小，或者保持不变。但是，试图在接下来的解释中涵盖所有这些情况是乏味且不太有说明性的，因此本指南将重点关注活跃堆保持不变的情况。GOGC章节将更详细地探讨非恒定活跃堆的情况。</p><p>在稳态中，当活跃堆的大小保持不变时，只要GC在相同的时间段之后执行，每个GC周期的成本模型看起来都是相同的。这是因为在固定的时间内，应用程序以固定的分配速率分配固定数量的新堆内存。因此，当活跃堆大小相同时，新堆内存使用始终相同。并且由于活跃堆大小相同，GC CPU成本将是相同的，并且固定成本将在某个规则的时间间隔内产生。</p><p>现在考虑如果GC将其运行的时间点向后移动。然后，会分配更多的内存，但每个GC周期仍然会产生相同的CPU成本。但在某个其他的固定时间窗口内，会完成更少的GC周期，从而导致更低的总CPU成本。如果GC决定更早地开始，则相反的情况也是如此：分配更少的内存，CPU成本会更频繁地产生。</p><p>这种情况代表了GC可以做出的CPU时间和内存之间的基本权衡，由GC实际执行的频率控制。换句话说，权衡完全由GC频率定义。</p><p>还有一个细节需要定义，那就是GC应该何时决定开始。请注意，这直接在任何特定稳态下设置GC频率，定义权衡。在Go中，决定GC何时开始是用户可以控制的主要参数。</p><h2 id="Go-GC"><a href="#Go-GC" class="headerlink" title="Go GC"></a>Go GC</h2><p>在高层次上，GOGC决定了GC CPU和内存之间的权衡。</p><p>它的工作方式是在每个GC周期后确定目标堆大小，即下一个周期中总堆大小的目标值。 GC的目标是在总堆大小超过目标堆大小之前完成收集周期。总堆大小定义为上一个周期结束时的活跃堆大小加上应用程序自上一个周期以来分配的任何新堆内存。与此同时，目标堆内存定义为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Target heap memory = Live heap + (Live heap + GC roots) * GOGC / 100</span><br></pre></td></tr></table></figure><p>举个例子，考虑一个Go程序，其中活跃堆大小为8 MiB，goroutine堆栈占用1 MiB，全局变量指针占用1 MiB。那么，在GOGC值为100的情况下，在下一次GC运行之前将分配10 MiB的新内存，即100%的10 MiB工作量，总堆占用为18 MiB。在GOGC值为50的情况下，它将是50%，或者5 MiB。在GOGC值为200的情况下，它将是200%，或者20 MiB。</p><p>注意：自Go 1.18起，GOGC仅包括根集。先前，它只计算活跃堆。通常，goroutine堆栈中的内存量相当小，而活跃堆大小主宰了所有其他GC工作源，但在程序有数十万个goroutine的情况下，GC做出了糟糕的判断。</p><p>堆目标控制GC频率：目标越大，GC可以等待更长时间才开始另一个标记阶段，反之亦然。虽然精确的公式对于做出估计非常有用，但最好从GOGC的基本目的来考虑它：它是一个参数，选择GC CPU和内存权衡点。关键是，将GOGC加倍将使堆内存开销加倍，GC CPU成本大致减半，反之亦然。（要查看完整的解释，请参见附录。）</p><p>注意：目标堆大小只是一个目标，GC周期可能不会恰好在该目标处结束，原因有几个。例如，足够大的堆分配可能会超过目标。然而，其他原因出现在超出本指南迄今使用的GC模型的GC实现中。有关更多详细信息，请参见延迟部分，但完整细节可在其他资源中找到。</p><p>GOGC 可以通过 GOGC 环境变量（所有 Go 程序都可以识别）或通过 runtime&#x2F;debug 包中的 SetGCPercent API 进行配置。</p><p>请注意，GOGC 也可以用于完全关闭 GC（前提是不受内存限制的影响），方法是设置 GOGC&#x3D;off 或调用 SetGCPercent(-1)。概念上，此设置相当于将 GOGC 设置为无穷大的值，因为在触发 GC 之前，分配的新内存量是没有限制的。</p><p>为了更好地理解我们迄今为止讨论的内容，请尝试使用下面的交互式可视化工具，该工具建立在先前讨论的 GC 成本模型之上。该可视化展示了执行某些程序所需的时间，该程序的非 GC 工作需要 10 秒的 CPU 时间才能完成。在第一秒钟，它执行一些初始化步骤（增加其活跃堆大小），然后进入稳态。该应用程序总共分配了 200 MiB 内存，其中每次只有 20 MiB 是活跃的。它假设完成的所有 GC 工作只来自于活跃堆，并且（不切实际地）应用程序不使用其他内存。</p><p>使用滑块调整 GOGC 的值，以查看应用程序在总持续时间和 GC 开销方面的响应情况。每个 GC 周期都在新堆下降为零时结束。新堆下降为零所需的时间是第 N 个周期的标记阶段和第 N+1 个周期的扫描阶段的组合时间。请注意，该可视化（以及本指南中的所有可视化工具）假设应用程序在 GC 执行时处于暂停状态，因此 GC CPU 成本完全由新堆内存下降所需的时间表示。这只是为了使可视化变得更简单，相同的直觉仍然适用。X 轴始终显示程序的完整 CPU 时间持续时间。请注意，GC 使用的额外 CPU 时间会增加总持续时间。</p><div class="gc-guide-graph" data-workload="[{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 9.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00}]" data-config="{&quot;fixedCost&quot;: 0.04,&quot;otherMem&quot;: 0,&quot;GOGC&quot;: &quot;graph1-gogc&quot;,&quot;memoryLimit&quot;: 100000}"></div><div class="gc-guide-graph-controls"><div>GOGC<input type="range" min="0" max="10" step="0.005" value="6.64" id="graph1-gogc"><div class="gc-guide-counter" id="graph1-gogc-display">100</div></div></div><p>请注意，GC总是会产生一些CPU和峰值内存开销。随着GOGC的增加，CPU开销减少，但峰值内存开销与活跃堆大小成比例增加。随着GOGC的减少，峰值内存需求减少，但会以额外的CPU开销为代价。</p><p>注意：图表显示的是CPU时间，而不是完成程序所需的挂钟时间。如果程序在一个CPU上运行并完全利用其资源，则两者是等价的。真实的程序可能在多核系统上运行，并且并不总是100％利用CPU。在这些情况下，GC对挂钟时间的影响会更低。</p><p>注意：Go GC具有4 MiB的最小总堆大小，因此如果GOGC设置的目标低于该值，它将被舍入。可视化反映了这个细节。</p><p>以下是另一个比较动态和现实的例子。再一次，应用程序在没有GC的情况下需要10个CPU秒才能完成，但稳态分配速率在中途急剧增加，而且在第一阶段中活跃堆大小会稍微变化。此示例演示了当活跃堆大小实际变化时，稳态可能看起来如何，以及更高的分配速率如何导致更频繁的GC周期。</p><div class="gc-guide-graph" data-workload="[{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.50},{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.50, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.50},{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.50, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 5.0, &quot;allocRate&quot;: 200, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.02, &quot;oldDeathRate&quot;: 1.00}]" data-config="{&quot;fixedCost&quot;: 0.04,&quot;otherMem&quot;: 0,&quot;GOGC&quot;: &quot;graph2-gogc&quot;,&quot;memoryLimit&quot;: 100000}"></div><div class="gc-guide-graph-controls"><div>GOGC<input type="range" min="0" max="10" step="0.005" value="6.64" id="graph2-gogc"><div class="gc-guide-counter" id="graph2-gogc-display">100</div></div></div><h2 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h2><p>在 Go 1.19 版本之前，GOGC 是唯一可用于修改 GC 行为的参数。虽然它在设置折衷方面表现出色，但它没有考虑可用内存是有限的。考虑一下当实时堆大小发生短暂的峰值时会发生什么：因为 GC 会选择一个与该实时堆大小成比例的总堆大小，所以即使在通常情况下更高的 GOGC 值提供了更好的折衷，GOGC 也必须配置为峰值实时堆大小。</p><p>下面的可视化演示了这种短暂的堆峰值情况。</p><div class="gc-guide-graph" data-workload="[{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 4.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.50},{&quot;duration&quot;: 3.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00}]" data-config="{&quot;fixedCost&quot;: 0.04,&quot;otherMem&quot;: 0,&quot;GOGC&quot;: &quot;graph3-gogc&quot;,&quot;memoryLimit&quot;: 100000}"></div><div class="gc-guide-graph-controls"><div>GOGC<input type="range" min="0" max="10" step="0.005" value="6.64" id="graph3-gogc"><div class="gc-guide-counter" id="graph3-gogc-display">100</div></div></div><p>如果示例工作负载运行在可用内存略高于60 MiB的容器中，则即使其余GC周期有可用内存可以利用，GOGC也无法增加到100。此外，在一些应用程序中，这些瞬时峰值可能很少且难以预测，导致偶尔出现不可避免且可能代价高昂的内存不足情况。</p><p>这就是为什么在1.19版本中，Go添加了对设置运行时内存限制的支持。内存限制可以通过所有Go程序都识别的GOMEMLIMIT环境变量或通过运行时&#x2F;debug包中可用的SetMemoryLimit函数进行配置。</p><p>此内存限制设置了Go运行时可以使用的总内存的最大值。所包含的内存集合是以runtime.MemStats表达式为基础定义的：</p><p>Sys - HeapReleased</p><p>或者以runtime&#x2F;metrics包的形式等效地表示为</p><p>&#x2F;memory&#x2F;classes&#x2F;total:bytes - &#x2F;memory&#x2F;classes&#x2F;heap&#x2F;released:bytes</p><p>由于 Go 的 GC 可以显式控制堆内存的使用量，因此它根据内存限制和 Go 运行时使用的其他内存量来设置总堆大小。</p><p>下面的可视化展示了与 GOGC 部分相同的单阶段稳定工作负载，但这次加上了来自 Go 运行时的额外 10 MiB 开销以及可调整的内存限制。尝试调整 GOGC 和内存限制，看看会发生什么。</p><div class="gc-guide-graph" data-workload="[    {&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0},    {&quot;duration&quot;: 9.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0}]" data-config="{    &quot;fixedCost&quot;: 0.04,    &quot;otherMem&quot;: 10,    &quot;GOGC&quot;: &quot;graph4-gogc&quot;,    &quot;memoryLimit&quot;: &quot;graph4-memlimit&quot;}"></div><div class="gc-guide-graph-controls">    <div>        GOGC        <input type="range" min="0" max="10" step="0.005" value="6.64" id="graph4-gogc">        <div class="gc-guide-counter" id="graph4-gogc-display">100</div>    </div>    <div>        Memory Limit        <input type="range" min="1" max="100" step="0.5" value="100" id="graph4-memlimit">        <div class="gc-guide-counter" id="graph4-memlimit-display">100.0 MiB</div>    </div></div><p>请注意，当内存限制低于由GOGC确定的峰值内存（对于GOGC为100，峰值内存为42 MiB）时，GC会更频繁地运行以将峰值内存保持在限制内。</p><p>回到之前的暂时堆峰值示例，通过设置内存限制和调高GOGC，我们可以获得两全其美的效果：没有内存限制违规，同时又获得更好的资源经济性。请尝试下面的交互式可视化。</p><div class="gc-guide-graph" data-workload="[    {&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},    {&quot;duration&quot;: 4.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00},    {&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},    {&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00},    {&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.50},    {&quot;duration&quot;: 3.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00}]" data-config="{    &quot;fixedCost&quot;: 0.04,    &quot;otherMem&quot;: 0,    &quot;GOGC&quot;: &quot;graph5-gogc&quot;,    &quot;memoryLimit&quot;: &quot;graph5-memlimit&quot;}"></div><div class="gc-guide-graph-controls">    <div>        GOGC        <input type="range" min="0" max="10" step="0.005" value="6.64" id="graph5-gogc">        <div class="gc-guide-counter" id="graph5-gogc-display">100</div>    </div>    <div>        Memory Limit        <input type="range" min="1" max="100" step="0.5" value="100" id="graph5-memlimit">        <div class="gc-guide-counter" id="graph5-memlimit-display">100.0 MiB</div>    </div></div><p>请注意，对于某些 GOGC 和内存限制的值，峰值内存使用将停止在内存限制处，但程序的其余执行仍遵守 GOGC 设定的总堆大小规则。</p><p>这一观察结果引出另一个有趣的细节：即使 GOGC 被关闭，内存限制仍然被遵守！事实上，这种特定的配置表示了一种资源利用率最大化，因为它设置了维持某个内存限制所需的最小 GC 频率。在这种情况下，程序的所有执行都会使堆大小上升以达到内存限制。</p><p>现在，尽管内存限制显然是一个强大的工具，但使用内存限制并不是没有代价的，并且当然也不会使 GOGC 失去效用。</p><p>考虑当活动堆增长到足以使总内存使用接近内存限制时会发生什么。在上面的稳定状态可视化中，试着关闭 GOGC，然后慢慢降低内存限制，观察会发生什么。注意到，随着 GC 不断执行以维持不可能的内存限制，应用程序的总执行时间将开始以无限制的方式增长。</p><h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><h2 id="额外资源"><a href="#额外资源" class="headerlink" title="额外资源"></a>额外资源</h2><h1 id="关于虚拟内存的说明"><a href="#关于虚拟内存的说明" class="headerlink" title="关于虚拟内存的说明"></a>关于虚拟内存的说明</h1><h1 id="优化指南"><a href="#优化指南" class="headerlink" title="优化指南"></a>优化指南</h1><h2 id="确定成本"><a href="#确定成本" class="headerlink" title="确定成本"></a>确定成本</h2><h2 id="消除堆分配"><a href="#消除堆分配" class="headerlink" title="消除堆分配"></a>消除堆分配</h2><h2 id="特定于实现的优化"><a href="#特定于实现的优化" class="headerlink" title="特定于实现的优化"></a>特定于实现的优化</h2><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="有关GOGC的其他说明"><a href="#有关GOGC的其他说明" class="headerlink" title="有关GOGC的其他说明"></a>有关GOGC的其他说明</h2><script src="https://taoshu.in/js/d3.js"></script><script src="https://taoshu.in/go/gc-guide.js"></script><link rel="stylesheet" href="/css/gc-guide.css">]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
