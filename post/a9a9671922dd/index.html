<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Go 垃圾回收器指南 | Yuamera's Blog</title><meta name="author" content="Yuamera"><meta name="copyright" content="Yuamera"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Go官方原文: A Guide to the Go Garbage Collector Introduction本指南旨在帮助高级 Go 用户通过深入了解 Go 垃圾回收器来更好地理解其应用程序成本，并提供指导，以利用这些见解改进其应用程序的资源利用率。读者阅读本指南不需要具备垃圾回收知识相关知识，需要熟悉 Go 编程语言。 Go 语言负责安排 Go 值的存储，在大多数情况下，Go 开发人员不需要">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 垃圾回收器指南">
<meta property="og:url" content="https://yuamera.github.io/post/a9a9671922dd/index.html">
<meta property="og:site_name" content="Yuamera&#39;s Blog">
<meta property="og:description" content="Go官方原文: A Guide to the Go Garbage Collector Introduction本指南旨在帮助高级 Go 用户通过深入了解 Go 垃圾回收器来更好地理解其应用程序成本，并提供指导，以利用这些见解改进其应用程序的资源利用率。读者阅读本指南不需要具备垃圾回收知识相关知识，需要熟悉 Go 编程语言。 Go 语言负责安排 Go 值的存储，在大多数情况下，Go 开发人员不需要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuamera.github.io/images/cover_go_00.jpg">
<meta property="article:published_time" content="2023-02-12T13:03:38.000Z">
<meta property="article:modified_time" content="2023-03-25T10:16:11.598Z">
<meta property="article:author" content="Yuamera">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuamera.github.io/images/cover_go_00.jpg"><link rel="shortcut icon" href="https://picx.zhimg.com/v2-8f4ab8b5cfcf8bde5ea9c37d268e5ff8_l.jpg"><link rel="canonical" href="https://yuamera.github.io/post/a9a9671922dd/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Yuamera","link":"链接: ","source":"来源: Yuamera's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go 垃圾回收器指南',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-03-25 18:16:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/global.css"><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picx.zhimg.com/v2-8f4ab8b5cfcf8bde5ea9c37d268e5ff8_l.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/images/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Yuamera's Blog"><span class="site-name">Yuamera's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/images/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Go 垃圾回收器指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-12T13:03:38.000Z" title="发表于 2023-02-12 21:03:38">2023-02-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-25T10:16:11.598Z" title="更新于 2023-03-25 18:16:11">2023-03-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go/">Go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go 垃圾回收器指南"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>Go官方原文: <a target="_blank" rel="noopener" href="https://tip.golang.org/doc/gc-guide">A Guide to the Go Garbage Collector</a></p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>本指南旨在帮助高级 Go 用户通过深入了解 Go 垃圾回收器来更好地理解其应用程序成本，并提供指导，以利用这些见解改进其应用程序的资源利用率。读者阅读本指南不需要具备垃圾回收知识相关知识，需要熟悉 Go 编程语言。</p>
<p>Go 语言负责安排 Go 值的存储，在大多数情况下，Go 开发人员不需要关心这些值存储在哪里，或者为什么（如果有的话）。实际上，这些值通常需要存储在计算机物理内存中，而物理内存是有限的资源。由于它是有限的，因此必须仔细管理内存并回收内存，以避免在执行 Go 程序时用尽内存。 Go 实现的工作是根据需要分配和回收内存。</p>
<p>自动回收内存的另一个术语是垃圾收集。在高层次上，垃圾收集器（或简称 GC）是一个系统，它通过识别不再需要的内存部分，代表应用程序回收内存。 Go 标准工具链提供了一个运行时库，该运行时库随每个应用程序一起提供，并包括垃圾回收器。</p>
<p>请注意，本指南所描述的垃圾收集器的存在并不是<a target="_blank" rel="noopener" href="https://tip.golang.org/ref/spec">Go specification（Go 规范）</a>所保证的，只是该语言本身管理 Go 值的底层存储。这种省略是故意的，并允许使用根本不同的内存管理技术。</p>
<p>因此，本指南是关于 Go 编程语言的特定实现，并可能不适用于其他实现。具体来说，以下指南适用于标准工具链（gc Go 编译器和工具）。 Gccgo 和 Gollvm 都使用非常相似的 GC 实现，因此许多相同的概念也适用，但详细信息可能会有所不同。</p>
<p>此外，这是一个不断发展的文档，随着时间的推移会进行更改，以最好地反映 Go 的最新发布。本文档当前描述的垃圾收集器是 Go 1.19 的垃圾收集器。</p>
<h2 id="Where-Go-Values-Live"><a href="#Where-Go-Values-Live" class="headerlink" title="Where Go Values Live"></a>Where Go Values Live</h2><p>在我们深入了解 GC 之前，让我们先讨论一下不需要由 GC 管理的内存。</p>
<p>例如，存储在局部变量中的非指针 Go 值可能根本不会由 Go GC 管理，而是 Go 将会安排与其创建时的词法作用域相关联的内存分配。通常，这比依赖 GC 更有效，因为 Go 编译器能够预测何时可以释放该内存并发出清理机器指令。通常，我们将这种方式分配 Go 值的内存称为“栈分配”，因为该空间存储在 goroutine 栈上。</p>
<p>由于 Go 编译器无法确定其生命周期，无法以这种方式分配内存的 Go 值被认为逃逸到堆上。堆可以被认为是用于内存分配的杂项区域，当需要将 Go 值放置在某处时，就会使用它。在堆上分配内存的行为通常称为“动态内存分配”，因为编译器和运行时可以做出非常少的假设，无法确定何时可以清除此内存。这就是 GC 的作用：它是一个专门识别和清理动态内存分配的系统。</p>
<p>Go 值可能需要逃逸到堆的原因有很多。其中一个原因可能是它的大小是动态确定的。例如，由变量而不是常量决定切片的初始大小的后备数组。请注意，逃逸到堆必须是可传递的：如果将对 Go 值的引用写入已确定逃逸的另一个 Go 值中，那么该值也必须逃逸。</p>
<p>Go 值是否逃逸取决于其使用的上下文和 Go 编译器的逃逸分析算法。尝试精确列举值何时逃逸将是脆弱且困难的：算法本身是相当复杂的，并且在 Go 发布之间会发生更改。有关如何确定哪些值会逃逸以及哪些值不会逃逸的更多详细信息，请参见有关消除堆分配的部分。</p>
<h2 id="Tracing-Garbage-Collection"><a href="#Tracing-Garbage-Collection" class="headerlink" title="Tracing Garbage Collection"></a>Tracing Garbage Collection</h2><p>垃圾回收可能指自动回收内存的许多不同方法，例如引用计数。在本文档的上下文中，垃圾回收指的是追踪式垃圾回收，该回收方法通过追踪指针的传递性来识别正在使用的对象，即所谓的活动对象。</p>
<p>让我们更严格地定义这些术语。</p>
<ul>
<li><p>对象 - 对象是包含一个或多个Go值的动态分配内存。</p>
</li>
<li><p>指针 - 引用对象内任何值的内存地址。这自然包括Go值的形式*T，但也包括内置Go值的部分。字符串，切片，通道，映射和接口值都包含GC必须跟踪的内存地址。</p>
</li>
</ul>
<p>对象和指向其他对象的指针共同形成对象图。为了识别活动内存，GC从程序的根开始遍历对象图，这些根是确切正在使用的对象的指针。局部变量和全局变量是两个根的示例。遍历对象图的过程称为扫描。</p>
<p>这个基本算法适用于所有追踪式GC。追踪式GC的不同之处在于它们发现内存活动后所做的事情。Go的GC使用标记-清除技术，这意味着为了跟踪其进度，GC也会将其遇到的值标记为活动的。一旦追踪完成，GC就会遍历堆中的所有内存，并将所有未标记的内存可供分配。这个过程称为清扫。</p>
<p>您可能熟悉的一种替代技术是将对象实际移动到内存的新部分，并留下一个转发指针，稍后用于更新所有应用程序的指针。我们将以这种方式移动对象的GC称为移动GC；Go具有非移动GC。</p>
<h1 id="The-GC-cycle"><a href="#The-GC-cycle" class="headerlink" title="The GC cycle"></a>The GC cycle</h1><p>由于Go GC是一个标记-清除GC，因此它通常分为两个阶段：标记阶段和清除阶段。虽然这个说法可能听起来有点自相矛盾，但它包含了一个重要的见解：在所有内存都被追踪之前，不可能将内存释放回分配池，因为可能仍有未扫描的指针使对象保持存活状态。因此，清扫的行为必须完全与标记的行为分离。此外，当没有与GC相关的工作需要执行时，GC可能根本不会活跃。GC会不断地在清除、关闭和标记这三个阶段之间进行循环，这就是所谓的GC周期。为了本文档的目的，我们假设GC周期从清除开始，然后关闭，最后是标记。</p>
<p>接下来的几节将专注于建立GC成本的直觉，以帮助用户调整GC参数以获得最大的效益。</p>
<h2 id="Understanding-costs"><a href="#Understanding-costs" class="headerlink" title="Understanding costs"></a>Understanding costs</h2><p>垃圾回收器本质上是建立在更为复杂的系统之上的复杂软件。当尝试理解垃圾回收器并调整其行为时，很容易陷入细节之中。本节旨在提供一个框架，用于推理Go GC成本并调整参数。</p>
<p>首先，考虑基于三个简单公理的GC成本模型。</p>
<p>GC仅涉及两种资源：CPU时间和物理内存。</p>
<p>GC的内存成本包括存活的堆内存、在标记阶段之前分配的新堆内存以及元数据空间。即使与前面的成本成比例，元数据空间相对较小。</p>
<p>注：存活的堆内存是由前一个GC周期确定为存活的内存，新堆内存是在当前周期分配的任何内存，可能在结束时是存活的也可能是死的。</p>
<p>GC的CPU成本被建模为每个周期的固定成本和与存活堆的大小成比例的边际成本。</p>
<p>注：从渐近意义上讲，扫描比标记和扫描更糟糕，因为它必须执行与整个堆的大小成比例的工作，包括被确定为不活动（即“死亡”）的内存。然而，在当前的实现中，扫描比标记和扫描要快得多，所以可以在本讨论中忽略其相关成本。</p>
<p>这个模型简单而有效：它准确地将GC的主要成本分类。但是，该模型未说明这些成本的大小以及它们如何相互作用。为了建立这种模型，请考虑以下情况，从这里开始称为稳态。</p>
<p>应用程序分配新内存的速率（每秒字节数）是恒定的。</p>
<p>注：重要的是要理解，此分配速率完全独立于新内存是否为活动内存。它们中的任何一个都可能是活动的，全部可能是活动的，也可能是其中的一些是活动的。（除此之外，一些旧堆内存也可能死亡，因此，如果该内存为活动内存，则活动堆大小并不一定增加。）</p>
<p>为了更具体地说明，考虑一个Web服务，为其处理的每个请求分配2 MiB的总堆内存。在请求期间，最多有512 KiB的2 MiB保持活动状态，而当服务完成处理请求时，所有这些内存都会死亡。现在，为了简单起见，假设每个请求大约需要1秒钟才能处理完全。然后，持续的请求流，例如每秒100个请求，将导致200 MiB&#x2F;s的分配速率和50 MiB的峰值活动堆。</p>
<p>应用程序的对象图每次看起来都差不多（对象大小相似，指针数量大约相同，图的最大深度大约相同）。</p>
<p>另一种思考方式是，GC的边际成本是恒定的。</p>
<p>注：稳态可能看起来有点牵强，但它代表了某个恒定工作量下应用程序的行为。当然，尽管应用程序在执行过程中负载可以改变，但通常应用程序的行为看起来像是一串这些稳态，之间还有一些短暂的行为。</p>
<p>注：稳态不对活跃堆（live heap）做任何假设。它可能会随着每个后续的GC周期而增长，也可能缩小，或者保持不变。但是，试图在接下来的解释中涵盖所有这些情况是乏味且不太有说明性的，因此本指南将重点关注活跃堆保持不变的情况。GOGC章节将更详细地探讨非恒定活跃堆的情况。</p>
<p>在稳态中，当活跃堆的大小保持不变时，只要GC在相同的时间段之后执行，每个GC周期的成本模型看起来都是相同的。这是因为在固定的时间内，应用程序以固定的分配速率分配固定数量的新堆内存。因此，当活跃堆大小相同时，新堆内存使用始终相同。并且由于活跃堆大小相同，GC CPU成本将是相同的，并且固定成本将在某个规则的时间间隔内产生。</p>
<p>现在考虑如果GC将其运行的时间点向后移动。然后，会分配更多的内存，但每个GC周期仍然会产生相同的CPU成本。但在某个其他的固定时间窗口内，会完成更少的GC周期，从而导致更低的总CPU成本。如果GC决定更早地开始，则相反的情况也是如此：分配更少的内存，CPU成本会更频繁地产生。</p>
<p>这种情况代表了GC可以做出的CPU时间和内存之间的基本权衡，由GC实际执行的频率控制。换句话说，权衡完全由GC频率定义。</p>
<p>还有一个细节需要定义，那就是GC应该何时决定开始。请注意，这直接在任何特定稳态下设置GC频率，定义权衡。在Go中，决定GC何时开始是用户可以控制的主要参数。</p>
<h2 id="Go-GC"><a href="#Go-GC" class="headerlink" title="Go GC"></a>Go GC</h2><p>在高层次上，GOGC决定了GC CPU和内存之间的权衡。</p>
<p>它的工作方式是在每个GC周期后确定目标堆大小，即下一个周期中总堆大小的目标值。 GC的目标是在总堆大小超过目标堆大小之前完成收集周期。总堆大小定义为上一个周期结束时的活跃堆大小加上应用程序自上一个周期以来分配的任何新堆内存。与此同时，目标堆内存定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Target heap memory = Live heap + (Live heap + GC roots) * GOGC / 100</span><br></pre></td></tr></table></figure>

<p>举个例子，考虑一个Go程序，其中活跃堆大小为8 MiB，goroutine堆栈占用1 MiB，全局变量指针占用1 MiB。那么，在GOGC值为100的情况下，在下一次GC运行之前将分配10 MiB的新内存，即100%的10 MiB工作量，总堆占用为18 MiB。在GOGC值为50的情况下，它将是50%，或者5 MiB。在GOGC值为200的情况下，它将是200%，或者20 MiB。</p>
<p>注意：自Go 1.18起，GOGC仅包括根集。先前，它只计算活跃堆。通常，goroutine堆栈中的内存量相当小，而活跃堆大小主宰了所有其他GC工作源，但在程序有数十万个goroutine的情况下，GC做出了糟糕的判断。</p>
<p>堆目标控制GC频率：目标越大，GC可以等待更长时间才开始另一个标记阶段，反之亦然。虽然精确的公式对于做出估计非常有用，但最好从GOGC的基本目的来考虑它：它是一个参数，选择GC CPU和内存权衡点。关键是，将GOGC加倍将使堆内存开销加倍，GC CPU成本大致减半，反之亦然。（要查看完整的解释，请参见附录。）</p>
<p>注意：目标堆大小只是一个目标，GC周期可能不会恰好在该目标处结束，原因有几个。例如，足够大的堆分配可能会超过目标。然而，其他原因出现在超出本指南迄今使用的GC模型的GC实现中。有关更多详细信息，请参见延迟部分，但完整细节可在其他资源中找到。</p>
<p>GOGC 可以通过 GOGC 环境变量（所有 Go 程序都可以识别）或通过 runtime&#x2F;debug 包中的 SetGCPercent API 进行配置。</p>
<p>请注意，GOGC 也可以用于完全关闭 GC（前提是不受内存限制的影响），方法是设置 GOGC&#x3D;off 或调用 SetGCPercent(-1)。概念上，此设置相当于将 GOGC 设置为无穷大的值，因为在触发 GC 之前，分配的新内存量是没有限制的。</p>
<p>为了更好地理解我们迄今为止讨论的内容，请尝试使用下面的交互式可视化工具，该工具建立在先前讨论的 GC 成本模型之上。该可视化展示了执行某些程序所需的时间，该程序的非 GC 工作需要 10 秒的 CPU 时间才能完成。在第一秒钟，它执行一些初始化步骤（增加其活跃堆大小），然后进入稳态。该应用程序总共分配了 200 MiB 内存，其中每次只有 20 MiB 是活跃的。它假设完成的所有 GC 工作只来自于活跃堆，并且（不切实际地）应用程序不使用其他内存。</p>
<p>使用滑块调整 GOGC 的值，以查看应用程序在总持续时间和 GC 开销方面的响应情况。每个 GC 周期都在新堆下降为零时结束。新堆下降为零所需的时间是第 N 个周期的标记阶段和第 N+1 个周期的扫描阶段的组合时间。请注意，该可视化（以及本指南中的所有可视化工具）假设应用程序在 GC 执行时处于暂停状态，因此 GC CPU 成本完全由新堆内存下降所需的时间表示。这只是为了使可视化变得更简单，相同的直觉仍然适用。X 轴始终显示程序的完整 CPU 时间持续时间。请注意，GC 使用的额外 CPU 时间会增加总持续时间。</p>
<div class="gc-guide-graph" data-workload="[{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 9.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00}]" data-config="{&quot;fixedCost&quot;: 0.04,&quot;otherMem&quot;: 0,&quot;GOGC&quot;: &quot;graph1-gogc&quot;,&quot;memoryLimit&quot;: 100000}"></div><div class="gc-guide-graph-controls"><div>GOGC<input type="range" min="0" max="10" step="0.005" value="6.64" id="graph1-gogc"><div class="gc-guide-counter" id="graph1-gogc-display">100</div></div></div>

<p>请注意，GC总是会产生一些CPU和峰值内存开销。随着GOGC的增加，CPU开销减少，但峰值内存开销与活跃堆大小成比例增加。随着GOGC的减少，峰值内存需求减少，但会以额外的CPU开销为代价。</p>
<p>注意：图表显示的是CPU时间，而不是完成程序所需的挂钟时间。如果程序在一个CPU上运行并完全利用其资源，则两者是等价的。真实的程序可能在多核系统上运行，并且并不总是100％利用CPU。在这些情况下，GC对挂钟时间的影响会更低。</p>
<p>注意：Go GC具有4 MiB的最小总堆大小，因此如果GOGC设置的目标低于该值，它将被舍入。可视化反映了这个细节。</p>
<p>以下是另一个比较动态和现实的例子。再一次，应用程序在没有GC的情况下需要10个CPU秒才能完成，但稳态分配速率在中途急剧增加，而且在第一阶段中活跃堆大小会稍微变化。此示例演示了当活跃堆大小实际变化时，稳态可能看起来如何，以及更高的分配速率如何导致更频繁的GC周期。</p>
<div class="gc-guide-graph" data-workload="[{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.50},{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.50, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.50},{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.50, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 5.0, &quot;allocRate&quot;: 200, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.02, &quot;oldDeathRate&quot;: 1.00}
]" data-config="{&quot;fixedCost&quot;: 0.04,&quot;otherMem&quot;: 0,&quot;GOGC&quot;: &quot;graph2-gogc&quot;,&quot;memoryLimit&quot;: 100000
}"></div><div class="gc-guide-graph-controls"><div>GOGC<input type="range" min="0" max="10" step="0.005" value="6.64" id="graph2-gogc"><div class="gc-guide-counter" id="graph2-gogc-display">100</div></div></div>


<h2 id="Memory-limit"><a href="#Memory-limit" class="headerlink" title="Memory limit"></a>Memory limit</h2><p>在 Go 1.19 版本之前，GOGC 是唯一可用于修改 GC 行为的参数。虽然它在设置折衷方面表现出色，但它没有考虑可用内存是有限的。考虑一下当实时堆大小发生短暂的峰值时会发生什么：因为 GC 会选择一个与该实时堆大小成比例的总堆大小，所以即使在通常情况下更高的 GOGC 值提供了更好的折衷，GOGC 也必须配置为峰值实时堆大小。</p>
<p>下面的可视化演示了这种短暂的堆峰值情况。</p>
<div class="gc-guide-graph" data-workload="[{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 4.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.50},{&quot;duration&quot;: 3.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00}
]" data-config="{&quot;fixedCost&quot;: 0.04,&quot;otherMem&quot;: 0,&quot;GOGC&quot;: &quot;graph3-gogc&quot;,&quot;memoryLimit&quot;: 100000
}"></div><div class="gc-guide-graph-controls"><div>GOGC<input type="range" min="0" max="10" step="0.005" value="6.64" id="graph3-gogc"><div class="gc-guide-counter" id="graph3-gogc-display">100</div></div></div>

<p>如果示例工作负载运行在可用内存略高于60 MiB的容器中，则即使其余GC周期有可用内存可以利用，GOGC也无法增加到100。此外，在一些应用程序中，这些瞬时峰值可能很少且难以预测，导致偶尔出现不可避免且可能代价高昂的内存不足情况。</p>
<p>这就是为什么在1.19版本中，Go添加了对设置运行时内存限制的支持。内存限制可以通过所有Go程序都识别的GOMEMLIMIT环境变量或通过运行时&#x2F;debug包中可用的SetMemoryLimit函数进行配置。</p>
<p>此内存限制设置了Go运行时可以使用的总内存的最大值。所包含的内存集合是以runtime.MemStats表达式为基础定义的：</p>
<p>Sys - HeapReleased</p>
<p>或者以runtime&#x2F;metrics包的形式等效地表示为</p>
<p>&#x2F;memory&#x2F;classes&#x2F;total:bytes - &#x2F;memory&#x2F;classes&#x2F;heap&#x2F;released:bytes</p>
<p>由于 Go 的 GC 可以显式控制堆内存的使用量，因此它根据内存限制和 Go 运行时使用的其他内存量来设置总堆大小。</p>
<p>下面的可视化展示了与 GOGC 部分相同的单阶段稳定工作负载，但这次加上了来自 Go 运行时的额外 10 MiB 开销以及可调整的内存限制。尝试调整 GOGC 和内存限制，看看会发生什么。</p>
<div class="gc-guide-graph" data-workload="[{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0},{&quot;duration&quot;: 9.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0}]" data-config="{&quot;fixedCost&quot;: 0.04,&quot;otherMem&quot;: 10,&quot;GOGC&quot;: &quot;graph4-gogc&quot;,&quot;memoryLimit&quot;: &quot;graph4-memlimit&quot;}"></div><div class="gc-guide-graph-controls"><div>GOGC<input type="range" min="0" max="10" step="0.005" value="6.64" id="graph4-gogc"><div class="gc-guide-counter" id="graph4-gogc-display">100</div></div><div>Memory Limit<input type="range" min="1" max="100" step="0.5" value="100" id="graph4-memlimit"><div class="gc-guide-counter" id="graph4-memlimit-display">100.0 MiB</div></div>
</div>

<p>请注意，当内存限制低于由GOGC确定的峰值内存（对于GOGC为100，峰值内存为42 MiB）时，GC会更频繁地运行以将峰值内存保持在限制内。</p>
<p>回到之前的暂时堆峰值示例，通过设置内存限制和调高GOGC，我们可以获得两全其美的效果：没有内存限制违规，同时又获得更好的资源经济性。请尝试下面的交互式可视化。</p>
<div class="gc-guide-graph" data-workload="[{&quot;duration&quot;: 1.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 4.0, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 1.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00},{&quot;duration&quot;: 0.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.50},{&quot;duration&quot;: 3.5, &quot;allocRate&quot;: 20, &quot;scanRate&quot;: 1024, &quot;newSurvivalRate&quot;: 0.00, &quot;oldDeathRate&quot;: 0.00}]" data-config="{&quot;fixedCost&quot;: 0.04,&quot;otherMem&quot;: 0,&quot;GOGC&quot;: &quot;graph5-gogc&quot;,&quot;memoryLimit&quot;: &quot;graph5-memlimit&quot;}"></div><div class="gc-guide-graph-controls"><div>GOGC<input type="range" min="0" max="10" step="0.005" value="6.64" id="graph5-gogc"><div class="gc-guide-counter" id="graph5-gogc-display">100</div></div><div>Memory Limit<input type="range" min="1" max="100" step="0.5" value="100" id="graph5-memlimit"><div class="gc-guide-counter" id="graph5-memlimit-display">100.0 MiB</div></div>
</div>

<p>请注意，对于某些 GOGC 和内存限制的值，峰值内存使用将停止在内存限制处，但程序的其余执行仍遵守 GOGC 设定的总堆大小规则。</p>
<p>这一观察结果引出另一个有趣的细节：即使 GOGC 被关闭，内存限制仍然被遵守！事实上，这种特定的配置表示了一种资源利用率最大化，因为它设置了维持某个内存限制所需的最小 GC 频率。在这种情况下，程序的所有执行都会使堆大小上升以达到内存限制。</p>
<p>现在，尽管内存限制显然是一个强大的工具，但使用内存限制并不是没有代价的，并且当然也不会使 GOGC 失去效用。</p>
<p>考虑当活动堆增长到足以使总内存使用接近内存限制时会发生什么。在上面的稳定状态可视化中，试着关闭 GOGC，然后慢慢降低内存限制，观察会发生什么。注意到，随着 GC 不断执行以维持不可能的内存限制，应用程序的总执行时间将开始以无限制的方式增长。</p>
<h2 id="Latency"><a href="#Latency" class="headerlink" title="Latency"></a>Latency</h2><h2 id="Additional-resources"><a href="#Additional-resources" class="headerlink" title="Additional resources"></a>Additional resources</h2><p>尽管上述信息是准确的，但它缺乏详细信息以充分了解Go GC设计中的成本和权衡。有关更多信息，请参阅以下其他资源。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gchandbook.org/">The GC Handbook</a>—An excellent general resource and reference on garbage collector design.</li>
<li><a target="_blank" rel="noopener" href="https://google.github.io/tcmalloc/design.html">TCMalloc</a>—Design document for the C&#x2F;C++ memory allocator TCMalloc, which the Go memory allocator is based on.</li>
<li><a target="_blank" rel="noopener" href="https://go.dev/blog/go15gc">Go 1.5 GC announcement</a>—The blog post announcing the Go 1.5 concurrent GC, which describes the algorithm in more detail.</li>
<li><a target="_blank" rel="noopener" href="https://go.dev/blog/ismmkeynote">Getting to Go</a>—An in-depth presentation about the evolution of Go’s GC design up to 2018.</li>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit">Go 1.5 concurrent GC pacing</a>—Design document for determining when to start a concurrent mark phase.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/30333">Smarter scavenging</a>—Design document for revising the way the Go runtime returns memory to the operating system.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/35112">Scalable page allocator</a>—Design document for revising the way the Go runtime manages memory it gets from the operating system.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/44167">GC pacer redesign (Go 1.18)</a>—Design document for revising the algorithm to determine when to start a concurrent mark phase.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/48409">Soft memory limit (Go 1.19)</a>—Design document for the soft memory limit.</li>
</ul>
<h1 id="A-note-about-virtual-memory"><a href="#A-note-about-virtual-memory" class="headerlink" title="A note about virtual memory"></a>A note about virtual memory</h1><h1 id="Optimization-guide"><a href="#Optimization-guide" class="headerlink" title="Optimization guide"></a>Optimization guide</h1><h2 id="Identifying-costs"><a href="#Identifying-costs" class="headerlink" title="Identifying costs"></a>Identifying costs</h2><p>Before trying to optimize how your Go application interacts with the GC, it’s important to first identify that the GC is a major cost in the first place.</p>
<p>The Go ecosystem provides a number of tools for identifying costs and optimizing Go applications. For a brief overview of these tools, see the guide on diagnostics. Here, we’ll focus on a subset of these tools and a reasonable order to apply them in in order to understand GC impact and behavior.</p>
<h3 id="CPU-profiles"><a href="#CPU-profiles" class="headerlink" title="CPU profiles"></a>CPU profiles</h3><p>A good place to start is with <a target="_blank" rel="noopener" href="https://pkg.go.dev/runtime/pprof#hdr-Profiling_a_Go_program">CPU profiling</a>. CPU profiling provides an overview of where CPU time is spent, though to the untrained eye it may be difficult to identify the magnitude of the role the GC plays in a particular application. Luckily, understanding how the GC fits in mostly boils down to knowing what different functions in the <code>runtime</code> package mean. Below is a useful subset of these functions for interpreting CPU profiles.</p>
<pre><code>_Note: the functions listed below are not leaf functions, so they may not show up in the default the `pprof` tool provides with the `top` command. Instead, use the `top -cum` command or use the `list` command on these functions directly and focus on the cumulative percent column._
</code></pre>
<ul>
<li><p><strong><code>runtime.gcBgMarkWorker</code></strong>: Entrypoint to the dedicated mark worker goroutines. Time spent here scales with GC frequency and the complexity and size of the object graph. It represents a baseline for how much time the application spends marking and scanning.</p>
<p><em>Note: In a largely idle Go application, the Go GC is going to use up additional (idle) CPU resources to get its job done faster. As a result, this symbol may represent a large fraction of samples, that it believes are free. One common reason this can happen is if an application runs entirely in one goroutine but</em> <code>GOMAXPROCS</code> <em>is &gt;1.</em></p>
</li>
<li><p><strong><code>runtime.mallocgc</code></strong>: Entrypoint to the memory allocator for heap memory. A large amount of cumulative time spent here (&gt;15%) typically indicates a lot of memory being allocated.</p>
</li>
<li><p><strong><code>runtime.gcAssistAlloc</code></strong>: Function goroutines enter to yield some of their time to assist the GC with scanning and marking. A large amount of cumulative time spent here (&gt;5%) indicates that the application is likely out-pacing the GC with respect to how fast it’s allocating. It indicates a particularly high degree of impact from the GC, and also represents time the application spend marking and scanning. Note that this is included in the <code>runtime.mallocgc</code> call tree, so it will inflate that as well.</p>
</li>
</ul>
<h3 id="Execution-traces"><a href="#Execution-traces" class="headerlink" title="Execution traces"></a>Execution traces</h3><p>While CPU profiles are great for identifying where time is spent in aggregate, they’re less useful for indicating performance costs that are more subtle, rare, or related to latency specifically. Execution traces on the other hand provide a rich and deep view into a short window of a Go program’s execution. They contain a variety of events related to the Go GC and specific execution paths can be directly observed, along with how the application might interact with the Go GC. All the GC events tracked are conveniently labeled as such in the trace viewer.</p>
<p>See the <a target="_blank" rel="noopener" href="https://pkg.go.dev/runtime/trace">documentation for the <code>runtime/trace</code></a> package for how to get started with execution traces.</p>
<h3 id="GC-traces"><a href="#GC-traces" class="headerlink" title="GC traces"></a>GC traces</h3><p>When all else fails, the Go GC provides a few different specific traces that provide much deeper insights into GC behavior. These traces are always printed directly to STDERR, one line per GC cycle, and are configured through the <code>GODEBUG</code> environment variable that all Go programs recognize. They’re mostly useful for debugging the Go GC itself since they require some familiarity with the specifics of the GC’s implementation, but nonetheless can occasionally be useful to gain a better understanding of GC behavior.</p>
<p>The core GC trace is enabled by setting <code>GODEBUG=gctrace=1</code>. The output produced by this trace is documented in the <a target="_blank" rel="noopener" href="https://pkg.go.dev/runtime#hdr-Environment_Variables">environment variables section in the documentation for the <code>runtime</code> package.</a></p>
<p>A supplementary GC trace called the “pacer trace” provides even deeper insights and is enabled by setting <code>GODEBUG=gcpacertrace=1</code>. Interpreting this output requires an understanding of the GC’s “pacer” (see <a target="_blank" rel="noopener" href="https://tip.golang.org/doc/gc-guide#Additional_resources">additional resources</a>), which is outside the scope of this guide.</p>
<h2 id="Eliminating-heap-allocations"><a href="#Eliminating-heap-allocations" class="headerlink" title="Eliminating heap allocations"></a>Eliminating heap allocations</h2><p>One way to reduce costs from the GC is to have the GC manage fewer values to begin with. The techniques described below can produce some of the largest improvements in performance, because as the <a target="_blank" rel="noopener" href="https://tip.golang.org/doc/gc-guide#GOGC">GOGC section</a> demonstrated, the allocation rate of a Go program is a major factor in GC frequency, the key cost metric used by this guide.</p>
<h3 id="Heap-profiling"><a href="#Heap-profiling" class="headerlink" title="Heap profiling"></a>Heap profiling</h3><p>After <a target="_blank" rel="noopener" href="https://tip.golang.org/doc/gc-guide#Identifying_costs">identifying that the GC is a source of significant costs</a>, the next step in eliminating heap allocations is to find out where most of them are coming from. For this purpose, memory profiles (really, heap memory profiles) are very useful. Check out the <a target="_blank" rel="noopener" href="https://pkg.go.dev/runtime/pprof#hdr-Profiling_a_Go_program">documentation</a> for how to get started with them.</p>
<p>Memory profiles describe where in the program heap allocations come from, identifying them by the stack trace at the point they were allocated. Each memory profile can break down memory in four ways.</p>
<ul>
<li><code>inuse_objects</code>—Breaks down the number of objects that are live.</li>
<li><code>inuse_space</code>—Breaks down live objects by how much memory they use in bytes.</li>
<li><code>alloc_objects</code>—Breaks down the number of objects that have been allocated since the Go program began executing.</li>
<li><code>alloc_space</code>—Breaks down the total amount of memory allocated since the Go program began executing.</li>
</ul>
<p>Switching between these different views of heap memory may be done with either the <code>-sample_index</code> flag to the <code>pprof</code> tool, or via the <code>sample_index</code> option when the tool is used interactively.</p>
<p><em>Note: memory profiles by default only sample a subset of heap objects so they will not contain information about every single heap allocation. However, this is sufficient to find hot-spots. To change the sampling rate, see <a target="_blank" rel="noopener" href="https://pkg.go.dev/runtime#pkg-variables"><code>runtime.MemProfileRate</code></a>.</em></p>
<p>For the purposes of reducing GC costs, <code>alloc_space</code> is typically the most useful view as it directly corresponds to the allocation rate. This view will indicate allocation hot spots that would provide the most benefit.</p>
<h3 id="Escape-analysis"><a href="#Escape-analysis" class="headerlink" title="Escape analysis"></a>Escape analysis</h3><p>Once candidate heap allocation sites have been identified with the help of <a target="_blank" rel="noopener" href="https://tip.golang.org/doc/gc-guide#Heap_profiling">heap profiles</a>, how can they be eliminated? The key is to leverage the Go compiler’s escape analysis to have the Go compiler find alternative, and more efficient storage for this memory, for example in the goroutine stack. Luckily, the Go compiler has the ability to describe why it decides to escape a Go value to the heap. With that knowledge, it becomes a matter of reorganizing your source code to change the outcome of the analysis (which is often the hardest part, but outside the scope of this guide).</p>
<p>As for how to access the information from the Go compiler’s escape analysis, the simplest way is through a debug flag supported by the Go compiler that describes all optimizations it applied or did not apply to some package in a text format. This includes whether or not values escape. Try the following command, where <code>[package]</code> is some Go package path.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags=-m=3 [package]</span><br></pre></td></tr></table></figure>

<p>This information can also be visualized as an overlay in VS Code. This overlay is configured and enabled in the VS Code Go plugin settings.</p>
<ol>
<li>Set the <a target="_blank" rel="noopener" href="https://github.com/golang/vscode-go/wiki/settings#uicodelenses"><code>ui.codelenses</code> setting to include <code>gc_details</code></a> .</li>
<li>Enable the overlay for escape analysis by <a target="_blank" rel="noopener" href="https://github.com/golang/vscode-go/wiki/settings#uidiagnosticannotations">setting <code>ui.diagnostic.annotations</code> to include <code>escape</code></a> .</li>
</ol>
<p>Finally, the Go compiler provides this information in a machine-readable (JSON) format that may be used to build additional custom tooling. For more information on that, see the <a target="_blank" rel="noopener" href="https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/logopt/log_opts.go;l=25;drc=351e0f4083779d8ac91c05afebded42a302a6893">documentation in the source Go code</a>.</p>
<h2 id="Implementation-specific-optimizations"><a href="#Implementation-specific-optimizations" class="headerlink" title="Implementation-specific optimizations"></a>Implementation-specific optimizations</h2><p>The Go GC is sensitive to the demographics of live memory, because a complex graph of objects and pointers both limits parallelism and generates more work for the GC. As a result, the GC contains a few optimizations for specific common structures. The most directly useful ones for performance optimization are listed below.</p>
<p><em>Note: Applying the optimizations below may reduce the readability of your code by obscuring intent, and may fail to hold up across Go releases. Prefer to apply these optimizations only in the places they matter most. Such places may be identified by using the tools listed in the <a target="_blank" rel="noopener" href="https://tip.golang.org/doc/gc-guide#Identifying_costs">section on identifying costs</a>.</em></p>
<ul>
<li><p>Pointer-free values are segregated from other values.</p>
<p>As a result, it may be advantageous to eliminate pointers from data structures that do not strictly need them, as this reduces the cache pressure the GC exerts on the program. As a result, data structures that rely on indices over pointer values, while less well-typed, may perform better. This is only worth doing if it’s clear that the object graph is complex and the GC is spending a lot of time marking and scanning.</p>
</li>
<li><p>The GC will stop scanning values at the last pointer in the value.</p>
<p>As a result, it may be advantageous to group pointer fields in struct-typed values at the beginning of the value. This is only worth doing if it’s clear the application spends a lot of its time marking and scanning. (In theory the compiler can do this automatically, but it is not yet implemented, and struct fields are arranged as written in the source code.)</p>
</li>
</ul>
<p>Furthermore, the GC must interact with nearly every pointer it sees, so using indices into an slice, for example, instead of pointers, can aid in reducing GC costs.</p>
<h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="Additional-notes-on-GOGC"><a href="#Additional-notes-on-GOGC" class="headerlink" title="Additional notes on GOGC"></a>Additional notes on GOGC</h2><p>The <a target="_blank" rel="noopener" href="https://tip.golang.org/doc/gc-guide#GOGC">GOGC section</a> claimed that doubling GOGC doubles heap memory overheads and halves GC CPU costs. To see why, let’s break it down mathematically.</p>
<p>Firstly, the heap target sets a target for the total heap size. This target, however, mainly influences the new heap memory, because the live heap is fundamental to the application.</p>
<center>Target heap memory = Live heap + (Live heap + GC roots) * GOGC / 100</center>

<center>Total heap memory = Live heap + New heap memory</center>

<center>⇒</center>

<center>New heap memory = (Live heap + GC roots) * GOGC / 100</center>

<p>From this we can see that doubling GOGC would also double the amount of new heap memory that application will allocate each cycle, which captures heap memory overheads. Note that <em>Live heap + GC roots</em> is an approximation of the amount of memory the GC needs to scan.</p>
<p>Next, let’s look at GC CPU cost. Total cost can be broken down as the cost per cycle, times GC frequency over some time period T.</p>
<center>Total GC CPU cost = (GC CPU cost per cycle) * (GC frequency) * T</center>

<p>GC CPU cost per cycle can be derived from the <a target="_blank" rel="noopener" href="https://tip.golang.org/doc/gc-guide#Understanding_costs">GC model</a>:</p>
<center>GC CPU cost per cycle = (Live heap + GC roots) * (Cost per byte) + Fixed cost</center>

<p>Note that sweep phase costs are ignored here as mark and scan costs dominate.</p>
<p>The steady-state is defined by a constant allocation rate and a constant cost per byte, so in the steady-state we can derive a GC frequency from this new heap memory:</p>
<center>GC frequency = (Allocation rate) / (New heap memory) = (Allocation rate) / ((Live heap + GC roots) * GOGC / 100)</center>

<p>Putting this together, we get the full equation for the total cost:</p>
<center><font size=1>Total GC CPU cost = (Allocation rate) / ((Live heap + GC roots) * GOGC / 100) * ((Live heap + GC roots) * (Cost per byte) + Fixed cost) * T</font></center>

<p>For a sufficiently large heap (which represents most cases), the marginal costs of a GC cycle dominate the fixed costs. This allows for a significant simplification of the total GC CPU cost formula.</p>
<center>Total GC CPU cost = (Allocation rate) / (GOGC / 100) * (Cost per byte) * T</center>

<p>From this simplified formula, we can see that if we double GOGC, we halve total GC CPU cost. (Note that the visualizations in this guide do simulate fixed costs, so the GC CPU overheads reported by them will not exactly halve when GOGC doubles.) Furthermore, GC CPU costs are largely determined by allocation rate and the cost per byte to scan memory. For more information on how to reduce these costs specifically, see the <a target="_blank" rel="noopener" href="https://tip.golang.org/doc/gc-guide#Optimization_guide">optimization guide</a>.</p>
<p><em>Note: there exists a discrepancy between the size of the live heap, and the amount of that memory the GC actually needs to scan: the same size live heap but with a different structure will result in a different CPU cost, but the same memory cost, resulting a different trade-off. This is why the structure of the heap is part of the definition of the steady-state. The heap target should arguably only include the scannable live heap as a closer approximation of memory the GC needs to scan, but this leads to degenerate behavior when there’s a very small amount of scannable live heap but the live heap is otherwise large.</em></p>
<script src="https://taoshu.in/js/d3.js"></script>
<script src="https://taoshu.in/go/gc-guide.js"></script>
<link rel="stylesheet" href="/css/gc-guide.css">
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post_share"><div class="social-share" data-image="/images/cover_go_00.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/5f52f7efa959/" title="Go GC 原理"><img class="cover" src="/images/cover_go_00.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">Go GC 原理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://picx.zhimg.com/v2-8f4ab8b5cfcf8bde5ea9c37d268e5ff8_l.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Yuamera</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yuamera" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yuamera@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Where-Go-Values-Live"><span class="toc-text">Where Go Values Live</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tracing-Garbage-Collection"><span class="toc-text">Tracing Garbage Collection</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-GC-cycle"><span class="toc-text">The GC cycle</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Understanding-costs"><span class="toc-text">Understanding costs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-GC"><span class="toc-text">Go GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-limit"><span class="toc-text">Memory limit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Latency"><span class="toc-text">Latency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Additional-resources"><span class="toc-text">Additional resources</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#A-note-about-virtual-memory"><span class="toc-text">A note about virtual memory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Optimization-guide"><span class="toc-text">Optimization guide</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Identifying-costs"><span class="toc-text">Identifying costs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-profiles"><span class="toc-text">CPU profiles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Execution-traces"><span class="toc-text">Execution traces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-traces"><span class="toc-text">GC traces</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Eliminating-heap-allocations"><span class="toc-text">Eliminating heap allocations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-profiling"><span class="toc-text">Heap profiling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Escape-analysis"><span class="toc-text">Escape analysis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementation-specific-optimizations"><span class="toc-text">Implementation-specific optimizations</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix"><span class="toc-text">Appendix</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Additional-notes-on-GOGC"><span class="toc-text">Additional notes on GOGC</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Yuamera</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://my-twikoo-blog.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://my-twikoo-blog.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,爱国,敬业,诚信,友善,自由,平等,公正,法治" data-fontsize="15px" data-random="false" async="async"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>